# frozen_string_literal: true

# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

require 'jwt'
require 'json/jwt'
require_relative 'errors'
require_relative 'request_helper'

module Stytch
  class IDP
    include Stytch::RequestHelper
    attr_reader :oauth

    def initialize(connection, project_id, policy_cache, jwks)
      @connection = connection

      @oauth = Stytch::IDP::OAuth.new(@connection)
      @policy_cache = policy_cache
      @project_id = project_id
      @cache_last_update = 0

      # If jwks are provided during initialization, use them directly
      if jwks
        @cached_keys = { keys: jwks }
        @cache_last_update = Time.now.to_i
      end

      @jwks_loader = lambda do |options|
        @cached_keys = nil if options[:invalidate] && @cache_last_update < Time.now.to_i - 300
        @cached_keys ||= begin
          @cache_last_update = Time.now.to_i
          keys = []
          get_jwks(project_id: @project_id)['keys'].each do |r|
            keys << r
          end
          { keys: keys }
        end
      end
    end

    # MANUAL(IDP::introspect_token_network)(SERVICE_METHOD)
    # ADDIMPORT: require 'jwt'
    # ADDIMPORT: require 'json/jwt'
    # ADDIMPORT: require_relative 'errors'

    # Introspects a token JWT from an authorization code response.
    # Access tokens are JWTs signed with the project's JWKs. Refresh tokens are opaque tokens.
    # Access tokens contain a standard set of claims as well as any custom claims generated from templates.
    #
    # == Parameters:
    # token::
    #   The access token (or refresh token) to introspect.
    #   The type of this field is +String+.
    # client_id::
    #   The ID of the client.
    #   The type of this field is +String+.
    # client_secret::
    #   The secret of the client.
    #   The type of this field is nilable +String+.
    # token_type_hint::
    #   A hint on what the token contains. Valid fields are 'access_token' and 'refresh_token'.
    #   The type of this field is +String+.
    # authorization_check::
    #   Optional authorization check object.
    #   The type of this field is nilable +Hash+.
    #
    # == Returns:
    # An object with the following fields:
    # subject::
    #   The subject of the token.
    #   The type of this field is +String+.
    # scope::
    #   The scope of the token.
    #   The type of this field is +String+.
    # audience::
    #   The audience of the token.
    #   The type of this field is +String+.
    # expires_at::
    #   The expiration time of the token.
    #   The type of this field is +Integer+.
    # issued_at::
    #   The issued at time of the token.
    #   The type of this field is +Integer+.
    # issuer::
    #   The issuer of the token.
    #   The type of this field is +String+.
    # not_before::
    #   The not before time of the token.
    #   The type of this field is +Integer+.
    # token_type::
    #   The type of the token.
    #   The type of this field is +String+.
    # custom_claims::
    #   Custom claims in the token.
    #   The type of this field is +Hash+.
    def introspect_token_network(
      token:,
      client_id:,
      client_secret: nil,
      token_type_hint: 'access_token',
      authorization_check: nil
    )
      headers = {}
      data = {
        'token' => token,
        'client_id' => client_id,
        'token_type_hint' => token_type_hint
      }
      data['client_secret'] = client_secret unless client_secret.nil?

      url = @connection.url_prefix + '/v1/oauth2/introspect'
      res = post_request(url, data, headers)

      jwt_response = res
      return nil unless jwt_response['active']

      custom_claims = res.reject { |k, _| non_custom_claim_keys.include?(k) }
      scope = jwt_response['scope']

      if authorization_check
        @policy_cache.perform_scope_authorization_check(
          token_scopes: scope.split,
          authorization_check: authorization_check
        )
      end

      {
        'subject' => jwt_response['sub'],
        'scope' => jwt_response['scope'],
        'audience' => jwt_response['aud'],
        'expires_at' => jwt_response['exp'],
        'issued_at' => jwt_response['iat'],
        'issuer' => jwt_response['iss'],
        'not_before' => jwt_response['nbf'],
        'token_type' => jwt_response['token_type'],
        'custom_claims' => custom_claims
      }
    end

    # Introspects a token JWT from an authorization code response.
    # Access tokens are JWTs signed with the project's JWKs. Refresh tokens are opaque tokens.
    # Access tokens contain a standard set of claims as well as any custom claims generated from templates.
    #
    # == Parameters:
    # access_token::
    #   The access token (or refresh token) to introspect.
    #   The type of this field is +String+.
    # authorization_check::
    #   Optional authorization check object.
    #   The type of this field is nilable +Hash+.
    #
    # == Returns:
    # An object with the following fields:
    # subject::
    #   The subject of the token.
    #   The type of this field is +String+.
    # scope::
    #   The scope of the token.
    #   The type of this field is +String+.
    # audience::
    #   The audience of the token.
    #   The type of this field is +String+.
    # expires_at::
    #   The expiration time of the token.
    #   The type of this field is +Integer+.
    # issued_at::
    #   The issued at time of the token.
    #   The type of this field is +Integer+.
    # issuer::
    #   The issuer of the token.
    #   The type of this field is +String+.
    # not_before::
    #   The not before time of the token.
    #   The type of this field is +Integer+.
    # token_type::
    #   The type of the token.
    #   The type of this field is +String+.
    # custom_claims::
    #   Custom claims in the token.
    #   The type of this field is +Hash+.
    def introspect_access_token_local(
      access_token:,
      authorization_check: nil
    )
      scope_claim = 'scope'
      begin
        decoded_jwt = JWT.decode(
          access_token,
          nil,
          true,
          {
            algorithms: ['RS256'],
            jwks: @jwks_loader,
            iss: ["stytch.com/#{@project_id}", @connection.url_prefix],
            aud: @project_id
          }
        )[0]

        generic_claims = decoded_jwt
        custom_claims = generic_claims.reject { |k, _| non_custom_claim_keys.include?(k) }
        scope = generic_claims[scope_claim]

        if authorization_check
          @policy_cache.perform_scope_authorization_check(
            token_scopes: scope.split,
            authorization_check: authorization_check
          )
        end

        {
          'subject' => generic_claims['sub'],
          'scope' => generic_claims[scope_claim],
          'audience' => generic_claims['aud'],
          'expires_at' => generic_claims['exp'],
          'issued_at' => generic_claims['iat'],
          'issuer' => generic_claims['iss'],
          'not_before' => generic_claims['nbf'],
          'token_type' => 'access_token',
          'custom_claims' => custom_claims
        }
      rescue JWT::InvalidIssuerError
        raise Stytch::JWTInvalidIssuerError
      rescue JWT::InvalidAudError
        raise Stytch::JWTInvalidAudienceError
      rescue JWT::ExpiredSignature
        raise Stytch::JWTExpiredSignatureError
      rescue JWT::IncorrectAlgorithm
        raise Stytch::JWTIncorrectAlgorithmError
      rescue JWT::DecodeError
        nil
      end
    end

    private

    def non_custom_claim_keys
      %w[
        aud
        exp
        iat
        iss
        jti
        nbf
        sub
        active
        client_id
        request_id
        scope
        status_code
        token_type
      ]
    end

    # Gets the JWKS for the project.
    #
    # == Parameters:
    # project_id::
    #   The ID of the project.
    #   The type of this field is +String+.
    #
    # == Returns:
    # The JWKS for the project.
    #   The type of this field is +Hash+.
    def get_jwks(project_id:)
      headers = {}
      query_params = {}
      request = request_with_query_params("/v1/sessions/jwks/#{project_id}", query_params)
      get_request(request, headers)
    end

    # ENDMANUAL(IDP::introspect_token_network)

    class OAuth
      include Stytch::RequestHelper

      def initialize(connection)
        @connection = connection
      end

      # Initiates a request for authorization of a Connected App to access a User's account.
      #
      # Call this endpoint using the query parameters from an OAuth Authorization request.
      # This endpoint validates various fields (`scope`, `client_id`, `redirect_uri`, `prompt`, etc...) are correct and returns
      # relevant information for rendering an OAuth Consent Screen.
      #
      # This endpoint returns:
      # - A public representation of the Connected App requesting authorization
      # - Whether _explicit_ user consent must be granted before proceeding with the authorization
      # - A list of scopes the user has the ability to grant the Connected App
      #
      # Use this response to prompt the user for consent (if necessary) before calling the [Submit OAuth Authorization](https://stytch.com/docs/api/connected-apps-oauth-authorize) endpoint.
      #
      # Exactly one of the following must be provided to identify the user granting authorization:
      # - `user_id`
      # - `session_token`
      # - `session_jwt`
      #
      # If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for tracking purposes.
      # One of these fields must be used if the Connected App intends to complete the [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
      #
      # == Parameters:
      # client_id::
      #   The ID of the Connected App client.
      #   The type of this field is +String+.
      # redirect_uri::
      #   The callback URI used to redirect the user after authentication. This is the same URI provided at the start of the OAuth flow.  This field is required when using the `authorization_code` grant.
      #   The type of this field is +String+.
      # response_type::
      #   The OAuth 2.0 response type. For authorization code flows this value is `code`.
      #   The type of this field is +String+.
      # scopes::
      #   An array of scopes requested by the client.
      #   The type of this field is list of +String+.
      # user_id::
      #   The unique ID of a specific User. You may use an `external_id` here if one is set for the user.
      #   The type of this field is nilable +String+.
      # session_token::
      #   The `session_token` associated with a User's existing Session.
      #   The type of this field is nilable +String+.
      # session_jwt::
      #   The `session_jwt` associated with a User's existing Session.
      #   The type of this field is nilable +String+.
      # prompt::
      #   Space separated list that specifies how the Authorization Server should prompt the user for reauthentication and consent. Only `consent` is supported today.
      #   The type of this field is nilable +String+.
      #
      # == Returns:
      # An object with the following fields:
      # request_id::
      #   Globally unique UUID that is returned with every API call. This value is important to log for debugging purposes; we may ask for this value to help identify a specific API call when helping you debug an issue.
      #   The type of this field is +String+.
      # user_id::
      #   The unique ID of the affected User.
      #   The type of this field is +String+.
      # user::
      #   The `user` object affected by this API call. See the [Get user endpoint](https://stytch.com/docs/api/get-user) for complete response field details.
      #   The type of this field is +User+ (+object+).
      # client::
      #   (no documentation yet)
      #   The type of this field is +ConnectedAppPublic+ (+object+).
      # consent_required::
      #   Whether the user must provide explicit consent for the authorization request.
      #   The type of this field is +Boolean+.
      # scope_results::
      #   Details about each requested scope.
      #   The type of this field is list of +ScopeResult+ (+object+).
      # status_code::
      #   (no documentation yet)
      #   The type of this field is +Integer+.
      def authorize_start(
        client_id:,
        redirect_uri:,
        response_type:,
        scopes:,
        user_id: nil,
        session_token: nil,
        session_jwt: nil,
        prompt: nil
      )
        headers = {}
        request = {
          client_id: client_id,
          redirect_uri: redirect_uri,
          response_type: response_type,
          scopes: scopes
        }
        request[:user_id] = user_id unless user_id.nil?
        request[:session_token] = session_token unless session_token.nil?
        request[:session_jwt] = session_jwt unless session_jwt.nil?
        request[:prompt] = prompt unless prompt.nil?

        post_request('/v1/idp/oauth/authorize/start', request, headers)
      end

      # Completes a request for authorization of a Connected App to access a User's account.
      #
      # Call this endpoint using the query parameters from an OAuth Authorization request, after previously validating those parameters using the
      # [Preflight Check](https://stytch.com/docs/api/connected-apps-oauth-authorize-start) API.
      # Note that this endpoint takes in a few additional parameters the preflight check does not- `state`, `nonce`, and `code_challenge`.
      #
      # If the authorization was successful, the `redirect_uri` will contain a valid `authorization_code` embedded as a query parameter.
      # If the authorization was unsuccessful, the `redirect_uri` will contain an OAuth2.1 `error_code`.
      # In both cases, redirect the user to the location for the response to be consumed by the Connected App.
      #
      # Exactly one of the following must be provided to identify the user granting authorization:
      # - `user_id`
      # - `session_token`
      # - `session_jwt`
      #
      # If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for tracking purposes.
      # One of these fields must be used if the Connected App intends to complete the [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
      #
      # == Parameters:
      # consent_granted::
      #   Indicates whether the user granted the requested scopes.
      #   The type of this field is +Boolean+.
      # scopes::
      #   An array of scopes requested by the client.
      #   The type of this field is list of +String+.
      # client_id::
      #   The ID of the Connected App client.
      #   The type of this field is +String+.
      # redirect_uri::
      #   The callback URI used to redirect the user after authentication. This is the same URI provided at the start of the OAuth flow.  This field is required when using the `authorization_code` grant.
      #   The type of this field is +String+.
      # response_type::
      #   The OAuth 2.0 response type. For authorization code flows this value is `code`.
      #   The type of this field is +String+.
      # user_id::
      #   The unique ID of a specific User. You may use an `external_id` here if one is set for the user.
      #   The type of this field is nilable +String+.
      # session_token::
      #   The `session_token` associated with a User's existing Session.
      #   The type of this field is nilable +String+.
      # session_jwt::
      #   The `session_jwt` associated with a User's existing Session.
      #   The type of this field is nilable +String+.
      # prompt::
      #   Space separated list that specifies how the Authorization Server should prompt the user for reauthentication and consent. Only `consent` is supported today.
      #   The type of this field is nilable +String+.
      # state::
      #   An opaque value used to maintain state between the request and callback.
      #   The type of this field is nilable +String+.
      # nonce::
      #   A string used to associate a client session with an ID token to mitigate replay attacks.
      #   The type of this field is nilable +String+.
      # code_challenge::
      #   A base64url encoded challenge derived from the code verifier for PKCE flows.
      #   The type of this field is nilable +String+.
      #
      # == Returns:
      # An object with the following fields:
      # request_id::
      #   Globally unique UUID that is returned with every API call. This value is important to log for debugging purposes; we may ask for this value to help identify a specific API call when helping you debug an issue.
      #   The type of this field is +String+.
      # redirect_uri::
      #   The callback URI used to redirect the user after authentication. This is the same URI provided at the start of the OAuth flow.  This field is required when using the `authorization_code` grant.
      #   The type of this field is +String+.
      # status_code::
      #   (no documentation yet)
      #   The type of this field is +Integer+.
      # authorization_code::
      #   A one-time use code that can be exchanged for tokens.
      #   The type of this field is nilable +String+.
      def authorize(
        consent_granted:,
        scopes:,
        client_id:,
        redirect_uri:,
        response_type:,
        user_id: nil,
        session_token: nil,
        session_jwt: nil,
        prompt: nil,
        state: nil,
        nonce: nil,
        code_challenge: nil
      )
        headers = {}
        request = {
          consent_granted: consent_granted,
          scopes: scopes,
          client_id: client_id,
          redirect_uri: redirect_uri,
          response_type: response_type
        }
        request[:user_id] = user_id unless user_id.nil?
        request[:session_token] = session_token unless session_token.nil?
        request[:session_jwt] = session_jwt unless session_jwt.nil?
        request[:prompt] = prompt unless prompt.nil?
        request[:state] = state unless state.nil?
        request[:nonce] = nonce unless nonce.nil?
        request[:code_challenge] = code_challenge unless code_challenge.nil?

        post_request('/v1/idp/oauth/authorize', request, headers)
      end
    end
  end
end
